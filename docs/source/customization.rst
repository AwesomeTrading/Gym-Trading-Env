Customization
==========

History object
--------------

The history object is similar to a DataFrame, but it was made to be faster. Its stores many training information at each timestep of the training. You can use it this way :

* ``history['column name', t]`` returns the a scalar value of the metrics 'column name' at time step t.
* ``history['column name']`` returns a numpy array with all the values from timestep 0 to current timestep.
* ``history[t]`` returns a dictionnary with of the metrics as keys with the associated values.

It was made to make everything easier :

* You can access **training info** like : ``step``, ``date``, ``reward``, ``position ```...
* It gathers **info from your initial DataFrame** and labels them with ``data_{column_name}`` like : ``data_close`` , ``data_open`` , ``data_high`` ....
* It stores the **portfolio valuation and distribution**

.. code-block:: python

 >>> history[33091]

.. code-block:: python

  {
  # Training info
   'step': 33091, #Step = t.
   'date': numpy.datetime64('2022-03-01T00:00:00.000000000'), #Date at step t, datetime.
   'position_index': 2, #Index of the position at step t amoung your position list.
   'position': 1, #Portfolio position at step t.
   'reward': 0.0028838985262525257, #Reward at step t.
  # DataFrame info : Every column (except features) of your initial DataFrame preceded by 'data_'
   'data_symbol': 'BTC/USD', 
   'data_volume': 52.05632, 
   'data_Volume USD': 2254677.3870464, 
   'data_high': 43626.49, 
   'data_open': 43221.71, 
   'data_close': 43312.27, 
   'data_unix': 1646092800, 
   'data_low': 43185.48,
  # Portfolio info : Distribution of the portfolio
   'portfolio_valuation': 45.3857471834205, #Global valuation of the portfolio
   'portfolio_distribution_asset': 0.001047869568779473, #the amount of owned BTC
   'portfolio_distribution_fiat': 0.0001374956603967803, #the amount of owned USD
   'portfolio_distribution_borrowed_asset': 0, #the amount of borrowed BTC (when position < 0 = SHORT)
   'portfolio_distribution_borrowed_fiat': 0, #the amount of borrowed USD (when position > 1)
   'portfolio_distribution_interest_asset': 0.0, #the cumalated interest generated by the borrowed BTC
   'portfolio_distribution_interest_fiat': 0.0, #the cumalated interest generated by the borrowed USD
  }
Custom reward function
-------------------

Use the history object to create your custom reward function. Bellow is an example with a really basic reward function :math:`r_{t} = ln(\frac{p_{t}}{p_{t-1}})\text{ with }p_{t}\text{ = portofolio valuation at timestep }t` (this is the default reward function).

.. code-block:: python

 import gymnasium as gym
 import numpy as np
 def reward_function(history):
         return np.log(history["portfolio_valuation", -1] / history["portfolio_valuation", -2])
 
 env = gym.make("TradingEnv",
         ...
         reward_function = reward_function
         ...
     )

Custom logs
-------------

If the ``verbose`` parameter of your trading environment is set to ``1`` or ``2``, the environment display a quick summary of your episode. By default `Market Return` and `Portfolio Return` are the displayed metrics.

.. code-block:: bash

  Market Return :  25.30%   |   Portfolio Return : 45.24%

You can add custom metrics using the method ``.add_metric(name, function)`` after initializing your environment :

.. code-block:: python
  
  env = gym.make("TradingEnv",
         ...
     )
  env.add_metric('Position Changes', lambda history : np.sum(np.diff(history['position']) != 0) )
  env.add_metric('Episode Lenght', lambda history : len(history['position']) )
  # Then, run your episode(s)

.. code-block:: bash

  Market Return :  25.30%   |   Portfolio Return : 45.24%   |   Position Changes : 28417   |   Episode Lenght : 33087

The ``.add_metric`` method takes 2 parameters :

* ``name`` : The displayed name of the metrics

* ``function`` : The function that takes the history object as parameters and returns a value (we obviously prefer string over other types here).


Custom render
-------------

The render runs with ``Flask`` on localhost as a web app, and the charts are drawn with the ``pyecharts`` librairy. The render needs to be rendered in a separate python script. This way you can explore your episode results without disturbing your RL-agent training.

In the *running environment script*, you need to save your render logs :

.. code-block:: python

  # At the end of the episode you want to render
  env.save_for_render(dir = "render_logs")

Then, in a *separate script* :

.. code-block:: python

  from gym_trading_env.renderer import Renderer
  renderer = Renderer(render_logs_dir="render_logs")
  renderer.run()

Add custom lines
^^^^^^^^^^^^^^^^

.. code-block:: python
  
  renderer = Renderer(render_logs_dir="render_logs")
  
  # Add Custom Lines (Simple Moving Average)
  renderer.add_line( name= "sma10", function= lambda df : df["close"].rolling(10).mean(), line_options ={"width" : 1, "color": "purple"})
  renderer.add_line( name= "sma20", function= lambda df : df["close"].rolling(20).mean(), line_options ={"width" : 1, "color": "blue"})
  
  renderer.run()

.. image:: images/custom_lines.PNG
  :width: 600
  :alt: Alternative text

Add custom lines with ``.add_line(name, function, line_options)`` that takes following parameters :

* ``name`` : The name of the line.
* ``function`` : The function takes the History object (converted into a DataFrame) of the episode as a parameter and needs to return a Series, 1-D array, or list of the lenght of the DataFrame.
* ``line_options`` *(optional)* : A Dict object that can have keys ``color``(str) and ``width``(int) to control the appearance of the plot.



Add custom metrics
^^^^^^^^^^^^^^^^

.. code-block:: python
  
  renderer = Renderer(render_logs_dir="render_logs")

  # Add Custom Metrics (Annualized metrics)
  renderer.add_metric(
      name = "Annual Market Return",
      function = lambda df : f"{ ((df['close'].iloc[-1] / df['close'].iloc[0])**(pd.Timedelta(days=365)/(df.index.values[-1] - df.index.values[0]))-1)*100:0.2f}%"
  )
  renderer.add_metric(
          name = "Annual Portfolio Return",
          function = lambda df : f"{((df['portfolio_valuation'].iloc[-1] / df['portfolio_valuation'].iloc[0])**(pd.Timedelta(days=365)/(df.index.values[-1] - df.index.values[0]))-1)*100:0.2f}%"
  )

  renderer.run()

.. image:: images/custom_metrics.PNG
  :width: 300
  :alt: Alternative text

Add custom metrics with ``.add_metric(name, function)`` that takes following parameters :

* ``name`` : The name of the metrics.
* ``function`` : The function takes the History object (converted into a DataFrame) of the episode as a parameter and needs to return a string.

